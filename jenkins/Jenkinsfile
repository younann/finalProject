pipeline {
    agent any

    // Arguments on whether we want to create the resource
    parameters {
        booleanParam(name: 'SKIP_TERRAFORM', defaultValue: false, description: 'Skip Terraform deployment?')
    }

    environment { // Global parameters
        AWS_ACCESS_KEY_ID     = credentials('aws-access-key')
        AWS_SECRET_ACCESS_KEY = credentials('aws-access-key')
        AWS_DEFAULT_REGION    = 'us-west-2'
        ECR_REPO_NAME         = 'python-app-repo'
        IMAGE_TAG             = 'latest'
        ECR_URL               = '211125613373.dkr.ecr.us-west-2.amazonaws.com/devsecops'
    }

    stages {
        stage('Checkout Code') { // Check the code
            steps {
                git branch: 'main', url: 'https://github.com/younann/finalProject.git'
            }
        }

        stage('AWS Authentication') { // Set AWS CLI for our code
            steps {
                sh '''
                    aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID
                    aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY
                    aws configure set region $AWS_DEFAULT_REGION
                    aws sts get-caller-identity
                '''
            }
        }

stage('Build Docker Image') {
    steps {
        script {
            // Enable BuildKit and build the Docker image
            sh "docker build -t ${ECR_REPO_NAME}:${IMAGE_TAG} ."
        }
    }}

  

        stage('Push Docker Image to ECR') {
            steps {
                script {
                    // Authenticate Docker to ECR
                    sh '''
                        aws ecr get-login-password --region ${AWS_DEFAULT_REGION} | \
                        docker login --username AWS --password-stdin ${ECR_URL}
                    '''

                    // Tag the Docker image for ECR
                    sh "docker tag ${ECR_REPO_NAME}:${IMAGE_TAG} ${ECR_URL}:${IMAGE_TAG}"

                    // Push the Docker image to ECR
                    sh "docker push ${ECR_URL}:${IMAGE_TAG}"
                }
            }
        }
              stage('Run Unit Tests') {
            steps {
                sh 'docker run --rm -e PYTHONPATH=/app -w /app ${ECR_REPO_NAME}:${IMAGE_TAG} pytest'
            }
        }

        stage('Terraform Init & Apply') { // Create AWS resources using Terraform
            when {
                expression { return !params.SKIP_TERRAFORM } // If already created, we can skip this stage
            }
            steps {
                dir('infra') {
                    sh 'terraform init'
                    sh 'terraform apply -auto-approve'
                }
            }
        }

        stage('Deploy to Kubernetes') {
            steps {
                script {
                    // Apply the Kubernetes manifest (test.yaml) from the k8s folder
                    sh "kubectl apply -f k8s/test.yaml --namespace=devsecops"
                    sh "kubectl rollout restart deployment my-app -n devsecops"
                }
            }
        }

        stage('Post-Deployment Test') { // Check if everything was installed correctly
            steps {
                script {
                    def serviceUrl = sh(script: "kubectl get svc my-app -n devsecops -o jsonpath='{.status.loadBalancer.ingress[0].hostname}'", returnStdout: true).trim()
                    echo "Service available at http://$serviceUrl"

                    def response = sh(script: "curl -s -o /dev/null -w '%{http_code}' http://$serviceUrl", returnStdout: true).trim()
                    if (response != "200") {
                        error("Post-deployment test failed! Service is unreachable.")
                    } else {
                        echo "Service is up and running!"
                    }
                }
            }
        }

        stage('Destroy all Resources Option') { // Option to destroy Terraform resources
            when {
                expression { return !params.SKIP_TERRAFORM }
            }
            steps {
                script {
                    def userInput = input(
                        id: 'userInput', 
                        message: 'Do you want to destroy the Terraform environment?', 
                        parameters: [
                            choice(
                                name: 'confirmDestroy', 
                                choices: ['Yes', 'No'], 
                                description: 'Choose "Yes" to destroy or "No" to skip.'
                            )
                        ]
                    )

                    if (userInput == 'Yes') {
                        dir('infra') {
                            sh 'terraform destroy -auto-approve'
                        }
                        echo "Terraform environment destroyed."
                    } else {
                        echo "Terraform destroy skipped."
                    }
                }
            }
        }

        stage('Cleanup on Failure') {
            when {
                expression { currentBuild.result == 'FAILURE' || currentBuild.result == null }
            }
            steps {
                script {
                    echo "Pipeline failed. Cleaning up resources..."
                    dir('infra') {
                        sh 'terraform destroy -auto-approve'
                    }
                }
            }
        }
    }

    post {
        echo 'Failed to deploy EKS cluster or application. Running cleanup...'
        sh "echo 'your_password' | sudo -S docker system prune -a -f" // Replace with your password or configure passwordless sudo
        // Optionally, run terraform destroy here if needed
        dir('infra') {
            sh 'terraform destroy -auto-approve'
        }
    }
}



/* ###make an empty cluster 
pipeline {
    agent any

    environment {
        AWS_ACCESS_KEY_ID     = credentials('aws-access-key')
        AWS_SECRET_ACCESS_KEY = credentials('aws-access-key')
        AWS_DEFAULT_REGION    = 'us-west-2' // Change to your preferred region
    }

    stages {
        stage('Checkout Code') {
            steps {
                git branch: 'main', url:'https://github.com/younann/finalProject.git' // Replace with your repo URL
            }
        }


        stage('Terraform Init') {
            steps {
                dir('infra') { // Change to the infra directory
                    sh 'terraform init'
                }
            }
        }

        stage('Terraform Plan') {
            steps {
                dir('infra') { // Change to the infra directory
                    sh 'terraform plan'
                }
            }
        }

        stage('Terraform Apply') {
            steps {
                dir('infra') { // Change to the infra directory
                    sh 'terraform apply -auto-approve'
                }
            }
        }
    }

    post {
        success {
            echo 'EKS cluster created successfully!'
        }
        failure {
            echo 'Failed to create EKS cluster.'
        }
        always {
            dir('infra') { // Change to the infra directory
                sh 'terraform destroy -auto-approve' // Clean up resources after the pipeline runs
            }
        }
    }
}
*/
